From eac45e29196bcde1d123a6035c15d30356bed248 Mon Sep 17 00:00:00 2001
From: Gregory Oschwald <goschwald@maxmind.com>
Date: Wed, 5 Aug 2020 14:16:17 -0700
Subject: [PATCH] Replace most malloc uses with calloc

Closes #236.
---
 Changes.md          |  4 ++++
 bin/mmdblookup.c    | 10 +++++-----
 doc/libmaxminddb.md |  2 +-
 src/maxminddb.c     | 21 ++++++++++++---------
 4 files changed, 22 insertions(+), 15 deletions(-)

#diff --git a/Changes.md b/Changes.md
#index 752ec284..2f1c29eb 100644
#--- a/Changes.md
#+++ b/Changes.md
#@@ -3,6 +3,10 @@
# * On Windows, always call `CreateFileW` instead of `CreateFile`.
#   `CreateFile` could be mapped to `CreateFileA` and not work as expected.
#   Pull request by Sandu Liviu Catalin. GitHub #228.
#+* Fixed use of uninitialized memory in `dump_entry_data_list()` that could
#+  cause a heap buffer flow in `mmdblookup`. As part of this fix, most uses
#+  of `malloc` were replaced with `calloc`. Reported by azhou. GitHub #236.
#+
# 
# ## 1.4.2 - 2019-11-02
# 
diff --git a/bin/mmdblookup.c b/bin/mmdblookup.c
index 4a3403c6..d7ec3fff 100644
--- a/bin/mmdblookup.c
+++ b/bin/mmdblookup.c
@@ -64,9 +64,9 @@ static void *thread(void *arg);
 int wmain(int argc, wchar_t **wargv)
 {
     // Convert our argument list from UTF-16 to UTF-8.
-    char **argv = (char **)malloc(argc * sizeof(char *));
+    char **argv = (char **)calloc(argc, sizeof(char *));
     if (!argv) {
-        fprintf(stderr, "malloc(): %s\n", strerror(errno));
+        fprintf(stderr, "calloc(): %s\n", strerror(errno));
         exit(1);
     }
     for (int i = 0; i < argc; i++) {
@@ -79,9 +79,9 @@ int wmain(int argc, wchar_t **wargv)
                     GetLastError());
             exit(1);
         }
-        utf8_string = malloc(utf8_width);
+        utf8_string = calloc(utf8_width, sizeof(char));
         if (!utf8_string) {
-            fprintf(stderr, "malloc(): %s\n", strerror(errno));
+            fprintf(stderr, "calloc(): %s\n", strerror(errno));
             exit(1);
         }
         if (WideCharToMultiByte(CP_UTF8, 0, wargv[i], -1, utf8_string,
@@ -294,7 +294,7 @@ LOCAL const char **get_options(
     }
 
     const char **lookup_path =
-        malloc(sizeof(const char *) * ((argc - optind) + 1));
+        calloc((argc - optind) + 1, sizeof(const char *));
     int i;
     for (i = 0; i < argc - optind; i++) {
         lookup_path[i] = argv[i + optind];
diff --git a/doc/libmaxminddb.md b/doc/libmaxminddb.md
index 191637b3..6e841cbc 100644
--- a/doc/libmaxminddb.md
+++ b/doc/libmaxminddb.md
@@ -307,7 +307,7 @@ libmaxminddb code.
 
 The `utf8_string`, `bytes`, and (maybe) the `uint128` members of this structure
 are all pointers directly into the database's data section. This can either be
-a `malloc`'d or `mmap`'d block of memory. In either case, these pointers will
+a `calloc`'d or `mmap`'d block of memory. In either case, these pointers will
 become invalid after `MMDB_close()` is called.
 
 If you need to refer to this data after that time you should copy the data
diff --git a/src/maxminddb.c b/src/maxminddb.c
index 21c18f2b..b45d5afa 100644
--- a/src/maxminddb.c
+++ b/src/maxminddb.c
@@ -36,7 +36,7 @@
     do {                                                        \
         char *binary = byte_to_binary(byte);                    \
         if (NULL == binary) {                                   \
-            fprintf(stderr, "Malloc failed in DEBUG_BINARY\n"); \
+            fprintf(stderr, "Calloc failed in DEBUG_BINARY\n"); \
             abort();                                            \
         }                                                       \
         fprintf(stderr, fmt "\n", binary);                      \
@@ -54,7 +54,7 @@
 #ifdef MMDB_DEBUG
 char *byte_to_binary(uint8_t byte)
 {
-    char *bits = malloc(sizeof(char) * 9);
+    char *bits = calloc(9, sizeof(char));
     if (NULL == bits) {
         return bits;
     }
@@ -321,7 +321,7 @@ int MMDB_open(const char *const filename, uint32_t flags, MMDB_s *const mmdb)
 LOCAL LPWSTR utf8_to_utf16(const char *utf8_str)
 {
     int wide_chars = MultiByteToWideChar(CP_UTF8, 0, utf8_str, -1, NULL, 0);
-    wchar_t *utf16_str = (wchar_t *)malloc(wide_chars * sizeof(wchar_t));
+    wchar_t *utf16_str = (wchar_t *)calloc(wide_chars, sizeof(wchar_t));
 
     if (MultiByteToWideChar(CP_UTF8, 0, utf8_str, -1, utf16_str,
                             wide_chars) < 1) {
@@ -704,7 +704,7 @@ LOCAL int populate_languages_metadata(MMDB_s *mmdb, MMDB_s *metadata_db,
                               MMDB_INVALID_METADATA_ERROR);
 
     mmdb->metadata.languages.count = 0;
-    mmdb->metadata.languages.names = malloc(array_size * sizeof(char *));
+    mmdb->metadata.languages.names = calloc(array_size, sizeof(char *));
     if (NULL == mmdb->metadata.languages.names) {
         return MMDB_OUT_OF_MEMORY_ERROR;
     }
@@ -722,7 +722,7 @@ LOCAL int populate_languages_metadata(MMDB_s *mmdb, MMDB_s *metadata_db,
         if (NULL == mmdb->metadata.languages.names[i]) {
             return MMDB_OUT_OF_MEMORY_ERROR;
         }
-        // We assign this as we go so that if we fail a malloc and need to
+        // We assign this as we go so that if we fail a calloc and need to
         // free it, the count is right.
         mmdb->metadata.languages.count = i + 1;
     }
@@ -774,7 +774,7 @@ LOCAL int populate_description_metadata(MMDB_s *mmdb, MMDB_s *metadata_db,
                               MMDB_INVALID_METADATA_ERROR);
 
     mmdb->metadata.description.descriptions =
-        malloc(map_size * sizeof(MMDB_description_s *));
+        calloc(map_size, sizeof(MMDB_description_s *));
     if (NULL == mmdb->metadata.description.descriptions) {
         status = MMDB_OUT_OF_MEMORY_ERROR;
         goto cleanup;
@@ -782,7 +782,7 @@ LOCAL int populate_description_metadata(MMDB_s *mmdb, MMDB_s *metadata_db,
 
     for (uint32_t i = 0; i < map_size; i++) {
         mmdb->metadata.description.descriptions[i] =
-            malloc(sizeof(MMDB_description_s));
+            calloc(1, sizeof(MMDB_description_s));
         if (NULL == mmdb->metadata.description.descriptions[i]) {
             status = MMDB_OUT_OF_MEMORY_ERROR;
             goto cleanup;
@@ -1134,7 +1134,7 @@ int MMDB_vget_value(MMDB_entry_s *const start,
     MAYBE_CHECK_SIZE_OVERFLOW(length, SIZE_MAX / sizeof(const char *) - 1,
                               MMDB_INVALID_METADATA_ERROR);
 
-    const char **path = malloc((length + 1) * sizeof(const char *));
+    const char **path = calloc(length + 1, sizeof(const char *));
     if (NULL == path) {
         return MMDB_OUT_OF_MEMORY_ERROR;
     }
@@ -2010,6 +2010,7 @@ LOCAL MMDB_entry_data_list_s *dump_entry_data_list(
             char *hex_string =
                 bytes_to_hex((uint8_t *)entry_data_list->entry_data.bytes,
                              entry_data_list->entry_data.data_size);
+
             if (NULL == hex_string) {
                 *status = MMDB_OUT_OF_MEMORY_ERROR;
                 return NULL;
@@ -2103,7 +2104,7 @@ LOCAL char *bytes_to_hex(uint8_t *bytes, uint32_t size)
     char *hex_string;
     MAYBE_CHECK_SIZE_OVERFLOW(size, SIZE_MAX / 2 - 1, NULL);
 
-    hex_string = malloc((size * 2) + 1);
+    hex_string = calloc((size * 2) + 1, sizeof(char));
     if (NULL == hex_string) {
         return NULL;
     }
@@ -2112,6 +2113,8 @@ LOCAL char *bytes_to_hex(uint8_t *bytes, uint32_t size)
         sprintf(hex_string + (2 * i), "%02X", bytes[i]);
     }
 
+
+
     return hex_string;
 }
 
